Design patterns are proven solutions to common software design problems.
They make code reusable, maintainable, and flexible.


Singleton Pattern: Ensures that only one instance of a class exists throughout the program.
Used when a single shared object should control actions — like configuration, logging, or database connections.

public class Singleton {
    private static Singleton instance;

    private Singleton() {} 

    public static Singleton getInstance() {
        if (instance == null)
            instance = new Singleton();
        return instance;
    }
}


Factory Pattern: Used to create objects without exposing the creation logic to the client.
Instead, we use a factory method to decide which class to instantiate.

interface Shape { void draw(); }

class Circle implements Shape { public void draw() { System.out.println("Circle"); } }
class Square implements Shape { public void draw() { System.out.println("Square"); } }

class ShapeFactory {
    public Shape getShape(String type) {
        if (type.equals("circle")) return new Circle();
        else if (type.equals("square")) return new Square();
        return null;
    }
}



Strategy Pattern: Allows us to define a family of algorithms, put each one in a separate class, and make them interchangeable at runtime.

This pattern helps when we want to change the behavior of an object dynamically.



MVC (Model–View–Controller) Pattern: Divides an application into three interconnected components to separate internal logic from UI.

Model: Represents data and business logic
View: Handles UI (what the user sees)
Controller: Connects the model and view; processes user input


Model: Student class with name and ID.

View: StudentView prints student details.

Controller: StudentController updates data and refreshes the view.




Builder Pattern: Used to construct complex objects step by step instead of calling a long constructor.

It’s useful when a class has many optional parameters.




