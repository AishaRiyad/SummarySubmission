
The file name must match the case-sensitive name of the top-level class (of which there is exactly one)
The file name must end with the .java extension.

Source files are encoded in UTF-8

the ASCII horizontal space character (0x20) is the only whitespace character that appears anywhere in a source file
No tabs, no non-breaking spaces, no special Unicode spaces, and no other invisible formatting characters should appear in the file

If we need to use non-space whitespace characters (like tabs or newlines) inside.
we must use escape sequences such as:

Tab -> \t
Newline -> \n
Carriage return -> \r
Form feed -> \f
Backspace -> \b
Quote -> \" , \'
Backslash -> \\


We Never use the tab key or the tab character (\t) to indent the code
Instead, we use space characters only (Google Java Style uses 2 spaces)

If we need to include non-ASCII characters (anything outside basic English letters, digits, and symbols), we have two options:

Using the actual character
Use the Unicode escape

 
Java source file consists of this(in this exact order):
-License or copyright information (if present)->Typically in the form of a multi-line comment at the very top of the file.
-Package declaration -> declaring the file's package (is not line-wrapped)
-Imports -> All import statements, grouped and ordered according to style guidelines(Wildcard(wildcard import is an import statement that imports all classes or static members) ("on-demand") imports, static or otherwise, are not used)&(not line-wrapped)
-Exactly one top-level class declaration 

(Exactly one blank line separates each section that is present)

A package-info.java file is the same, but without the class declaration:
package-info.java is a special Java source file used to provide:

-Package-level Javadoc comments

-Package-level annotations

A module-info.java file does not contain a package declaration and replaces the class declaration with a module declaration, but otherwise follows the same structure.



Ordering and spacing:
All static imports in a single group & All non-static imports in a single group.

*If there are both static and non-static imports, a single blank line separates the two groups. There are no other blank lines between imports.
Within each group the imported names appear in ASCII sort order.(Sort by the full import statement string.)



Static import is not used for static nested classes. They are imported with normal imports


Ordering of class contents:
While there's no universally "correct" order, it's essential to adopt a logical and consistent structure within each class. This ensures that any developer can understand the reasoning behind the chosen order.


"Overloads: never split" 
from the Google Java Style Guide emphasizes that methods and constructors with the same name should be grouped together without any intervening members(nothing else should be placed between them). This ensures clarity and maintainability in your codebase.


Ordering and spacing of module directives:
-All requires directives in a single block.
-All exports directives in a single block.
-All opens directives in a single block.
-All uses directives in a single block.
-All provides directives in a single block.

A single blank line separates each block that is present.


In the style guide, a block‑like construct means the content enclosed by braces ( { ... } ) in:

-A class (i.e. the class body)
-A method (its body)
-A constructor (its body)
-A switch (the code inside switch’s { ... })

So whenever we see a rule that refers to “within a block‑like construct,” it applies inside those curly-brace bodies.

Braces are used with if, else, for, do and while statements, even when the body is empty or contains only a single statement.

Other optional braces, such as those in a lambda expression, remain optional.


No line break before the opening brace, except as detailed below.
Line break after the opening brace.
Line break before the closing brace.
Line break after the closing brace, only if that brace terminates a statement or terminates the body of a method, constructor, or named class. For example, there is no line break after the brace if it is followed by else or a comma.


An empty block or block-like construct may be in K & R style (as described in Section 4.1.2). Alternatively, it may be closed immediately after it is opened, with no characters or line break in between ({}), unless it is part of a multi-block statement (one that directly contains multiple blocks: if/else or try/catch/finally).



-Every time you enter a block (e.g. after { in a method, if, for, while, class body, etc.), you indent further by 2 spaces relative to where you were before the block.

-When you exit that block (i.e. after the closing }), you go back to the previous indentation level.

-This rule applies not only to code statements but also to comments inside the block.


Each statement is followed by a line break.


-Java code should not exceed 100 characters per line (counting each Unicode code point as one)
-If a line would go past that limit, we must line-wrap it (break it into multiple lines) according to the rules in Section 4.5.
-Even if a Unicode character is visually wide (or narrow), you still count it as one toward the limit
-If we are using fullwidth characters (e.g. some East-Asian characters that look wide), we may wrap earlier if it helps readability—even if we haven’t strictly hit 100 by the code-point count.


We do not have to wrap lines in these cases:
-Lines where wrapping is not feasible — e.g. a very long URL in Javadoc, or a JSNI native method reference.
-Package declarations and import statements — these are exempt from the 100-character limit.
-Text blocks (Java’s multi-line string literal feature) — their contents can exceed 100 chars per line.
-Command lines in comments that readers might copy‑and‑paste into a shell.
-Very long identifiers, in rare cases — if an identifier itself is long, it may exceed 100 characters. In that case, the surrounding code is wrapped in a “valid” way using google-java-format rules.



Prefer breaking at a higher syntactic level: That means, break at a larger chunk (like between clauses) rather than inside a deeply nested expression. 

Non-assignment operators:
-If we break at an operator (like +, -, etc.), the break comes before the operator.
-This also applies to “operator-like” symbols: dot(.), method reference(::),(&),a pipe (|)

Assignment operators:
-Breaks typically come after the operator
-this also includes the colon : in a “for-each”

Method/constructor name + parenthesis: The name (or constructor) stays bound to its opening parenthesis. You shouldn’t break between them.

Comma: A comma should stay attached to the preceding token. In other words, don’t break before the comma.

Lambdas and switch rules (arrow ->): We should not break right adjacent to the arrow, except in some specific case:
If the code after the arrow is a single unbraced expression, you may break immediately after the arrow.



Indentation for Continuation Lines:
-When a line is wrapped, the subsequent lines (continuation lines) must be indented to indicate that they are part of the previous statement.
     *Indentation Level: Each continuation line should be indented by at least 4 spaces relative to the original line.
     *Consistency: If there are multiple continuation lines, they should maintain the same indentation level, especially if they begin with syntactically parallel  
      elements.



vertical whitespace:
-Between Consecutive Class Members or Initializers: This includes fields, constructors, methods, nested classes, static initializers, and instance initializers.
    -Exception: A blank line between two consecutive fields (with no other code between them) is optional. Such blank lines are used as needed to create logical 
     groupings of fields.


horizontal whitespace:
-After Keywords: Place a space between any keyword (e.g., if, for, catch) and the opening parenthesis ( that follows it.
-Before Keywords: Place a space between any keyword (e.g., else, catch) and the closing curly brace } that precedes it.
-Before Opening Braces: Insert a space before any opening curly brace {, with two exceptions:
        -In annotations with array initializers, such as @SomeAnnotation({a, b}), no space is used.
        -In array initializers, such as String[][] x = {{"foo"}};, no space is required between the braces.



Grouping Parentheses 

Omit optional parentheses only when both author and reviewer are confident omission won’t cause misreading. Don’t assume everyone knows full operator precedence.


Enums: Allow some special formatting; enum constants separation rules.


Around Operators:
Use spaces on both sides of any binary or ternary operator. This also applies to the following "operator-like" symbols:
following "operator-like" symbols:

  -The ampersand & that separates multiple type bounds: <T extends Foo & Bar>
  -The pipe | for a catch block that handles multiple exceptions: catch (FooException | BarException e)
  -The colon : in an enhanced for ("foreach") statement: for (String s : list)
  -The arrow -> in a lambda expression: (String str) -> str.length()
  -The arrow -> in a switch rule: case "FOO" -> bar();


After Comma, Colon, Semicolon, or Closing Parenthesis: Insert a space after ,, :, ;, or the closing parenthesis ) of a cast.

Before Comments: Place a space between any content and a double slash // that begins a comment. Multiple spaces are allowed.

Within Comments: Place a space between a double slash // that begins a comment and the comment's text. Multiple spaces are allowed.

Between Type and Identifier in Declarations: Insert a space between the type and identifier of a declaration: List<String> list.

Inside Array Initializers: Optional just inside both braces of an array initializer. For example, new int[] {5, 6} and new int[] { 5, 6 } are both valid.

Between Type Annotation and Array Brackets: Insert a space between a type annotation and [] or ....


Horizontal alignment refers to adding extra spaces to line up tokens (identifiers, comments, etc.) in different lines so that certain columns match visually.

Google Style permits alignment, but it is never required. We do not have to align things this way, and we don’t need to preserve alignment in existing code if it becomes inconvenient.


After the comma that follows an enum constant, a line break is optional. Additional blank lines (usually just one) are also allowed.



Variable declarations:
-When we declare a variable (either as a class field or a local variable), we should only declare one variable in that statement.

-we should not combine multiple variable declarations of the same type in one line using commas (e.g. int a, b; is disallowed).

-The only time we’re allowed to declare multiple variables in one line is in the initialization section of a for loop (e.g. for (int i = 0, j = n; i < j; i++) { … }).


-we don't always put all local variable declarations at the top of a method or block.

-Instead, we declare variables just before their first use, so their scope is as small as possible.

-Local variable declarations should often include an initializer, or otherwise be initialized immediately after declaration.


The square brackets form a part of the type, not the variable: String[] args, not String args[].


Switch block: The content between { ... } in a switch.

In new-style, the block contains one or more switch rules:

A switch rule = a case (or default) label followed by -> and then either an expression, a block, or a throw.

In old-style, the block contains one or more statement groups:

A statement group = one or more case (or default) labels, each followed by a colon, then one or more statements (or none for the final group).



Annotations:

  -Type-use annotations appear immediately before the annotated type.
  -Class, package, module annotations: each on its own line, after the Javadoc block.
  -Method/constructor annotations similarly, though a single no‑parameter annotation may appear on the same line as signature.
  -Field annotations: appear after Javadoc; multiple annotations may appear on the same line.
  -There are no strict layout rules for annotations on parameters/local variables (beyond general spacing).


Comments:

  -Block comments (/* … */) or // style are allowed. Multi-line block comments: each new line “*” aligned.
  -Comments should match the surrounding indent.
  -Use TODO: format for temporary notes — uppercase TODO, colon, link or bug reference, hyphen then explanation.


Modifiers:

  -Order of modifiers for classes and members must follow the Java Language Specification’s recommended sequence
  -In module directives (in module-info.java), modifiers on requires are in order transitive static


Numeric literals: Use uppercase L for long integer suffix (3000000000L, not 3000000000l).

  
Text blocks (multi-line string literals):

  -The opening """ is on a new line. It may be indented or start in column 0. The closing """ aligns with the opening.
  -Each line inside the text block must be indented at least as much as the opening/closing delimiter. Excess indentation becomes part of the literal.
  -Text block contents may exceed the 100-character limit.


Naming Conventions:

  -Identifiers use only ASCII letters and digits (and in limited cases underscores). No prefixes or suffixes like mName, s_name, name_.
  -Package and module names: lowercase letters and digits only, no underscores.
  -Class names: UpperCamelCase (typically nouns/noun phrases).
  -Method names: lowerCamelCase (typically verbs)
  -Constant names (static final, deeply immutable): UPPER_SNAKE_CASE.
  -Non-constant field names, parameter names, local variable names: lowerCamelCase.
  -Type variable names: a single capital letter, optionally with one digit (e.g. T, X2), or a descriptive name ending in T.



Programming Practices:

  -Always annotate overridden methods with @Override when allowed (with exception when parent is @Deprecated).
  -Don’t silently ignore caught exceptions — either log or rethrow; if you truly ignore, explain why in a comment.
  -When qualifying static members, always use the class name (not an instance). e.g. ClassName.staticMethod().
  -Do not override Object.finalize().



Javadoc:

  -Javadoc for public classes and visible members is required (with exceptions)
  -One-line Javadoc is allowed when the entire block (including markers) fits on one line and has no block tags. 
  -The first sentence (summary fragment) should be a noun or verb phrase, not a full sentence
  -A blank Javadoc comment line (*) separates paragraphs, and a blank one appears before block tags (@param, etc.).
  -Block tags must appear in this order (if present): @param, @return, @throws, @deprecated. None of them should have an empty description.
  -Javadoc may be omitted for “obvious” simple methods (e.g. simple getters) only if truly no additional information is necessary.











